import express from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateToken, requireAdmin } from '../middleware/auth.js';

const router = express.Router();
const prisma = new PrismaClient();

// Middleware para logging
router.use((req, res, next) => {
  console.log(`üîë Admin API: ${req.method} ${req.path}`);
  next();
});

// Aplicar middleware de autenticaci√≥n y autorizaci√≥n
router.use(authenticateToken);
router.use(requireAdmin);

/**
 * GET /api/admin/stats
 * Obtiene estad√≠sticas generales del dashboard de administraci√≥n
 */
router.get('/stats', async (req, res) => {
  try {
    console.log('[ADMIN] Obteniendo estad√≠sticas del dashboard...');

    const [
      totalUsers,
      clientsCount,
      evaluatorsCount,
      collectorsCount,
      systemParameters,
      articleTypes,
      storeProducts,
      activeSessions,
      pendingRequests,
      overdueLoans
    ] = await Promise.all([
      // Total de usuarios
      prisma.usuario.count(),
      
      // Total de clientes
      prisma.usuario.count({
        where: { tipoUsuario: 'Cliente' }
      }),
      
      // Total de evaluadores
      prisma.usuario.count({
        where: { tipoUsuario: 'Evaluador' }
      }),
      
      // Total de cobradores
      prisma.usuario.count({
        where: { tipoUsuario: 'Cobrador' }
      }),
      
      // Total de par√°metros del sistema
      prisma.parametrosSistema.count({
        where: {
          nombreParametro: {
            not: {
              startsWith: 'ECOMMERCE_'
            }
          }
        }
      }),
      
      // Total de tipos de art√≠culos
      prisma.tipoArticulo.count({
        where: { estado: 'Activo' }
      }),
      
      // Total de productos en tienda
      prisma.productoTienda.count({
        where: { estado: 'Disponible' }
      }),
      
      // Sesiones activas recientes (√∫ltimas 24 horas)
      prisma.sesionUsuario.count({
        where: {
          fechaInicio: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000)
          }
        }
      }),
      
      // Solicitudes pendientes
      prisma.solicitudPrestamo.count({
        where: { estado: 'Pendiente' }
      }),
      
      // Pr√©stamos vencidos
      prisma.prestamo.count({
        where: { estado: 'Vencido' }
      })
    ]);

    const stats = {
      totalUsers,
      clientsCount,
      activeStaff: evaluatorsCount + collectorsCount,
      evaluators: evaluatorsCount,
      collectors: collectorsCount,
      systemParameters,
      articleTypes,
      storeProducts,
      activeSessions,
      pendingRequests,
      overdueLoans,
      newUsersToday: 0, // TODO: Implementar con fecha actual
      currentRate: 0 // TODO: Obtener de par√°metros
    };

    console.log('‚úÖ Estad√≠sticas obtenidas:', stats);

    res.status(200).json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('[ERROR] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas del dashboard'
    });
  }
});

/**
 * GET /api/admin/recent-activity
 * Obtiene actividad reciente del sistema
 */
router.get('/recent-activity', async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    console.log(`[ADMIN] Obteniendo actividad reciente (l√≠mite: ${limit})...`);

    const [recentSessions, recentRequests, recentPayments] = await Promise.all([
      // Sesiones recientes
      prisma.sesionUsuario.findMany({
        take: parseInt(limit),
        orderBy: { fechaInicio: 'desc' },
        include: {
          usuario: {
            select: {
              nombre: true,
              apellido: true,
              email: true,
              tipoUsuario: true
            }
          }
        }
      }),

      // Solicitudes recientes
      prisma.solicitudPrestamo.findMany({
        take: parseInt(limit),
        orderBy: { fechaSolicitud: 'desc' },
        include: {
          usuario: {
            select: {
              nombre: true,
              apellido: true
            }
          }
        }
      }),

      // Pagos recientes
      prisma.pago.findMany({
        take: parseInt(limit),
        orderBy: { fechaPago: 'desc' },
        include: {
          prestamo: {
            include: {
              contrato: {
                include: {
                  solicitud: {
                    include: {
                      usuario: {
                        select: {
                          nombre: true,
                          apellido: true
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      })
    ]);

    res.status(200).json({
      success: true,
      data: {
        recentSessions,
        recentRequests,
        recentPayments
      }
    });

  } catch (error) {
    console.error('[ERROR] Error obteniendo actividad reciente:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo actividad reciente'
    });
  }
});

// ===== RUTAS DE PAR√ÅMETROS DEL SISTEMA =====

/**
 * GET /api/admin/system-parameters
 * Obtiene todos los par√°metros del sistema
 */
router.get('/system-parameters', async (req, res) => {
  try {
    console.log('[ADMIN] Obteniendo par√°metros del sistema...');

    const parameters = await prisma.parametrosSistema.findMany({
      include: {
        usuarioModifico: {
          select: {
            nombre: true,
            apellido: true,
            email: true
          }
        }
      },
      orderBy: { nombreParametro: 'asc' }
    });

    console.log(`‚úÖ ${parameters.length} par√°metros encontrados`);

    res.status(200).json({
      success: true,
      data: { parameters }
    });

  } catch (error) {
    console.error('[ERROR] Error obteniendo par√°metros:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo par√°metros del sistema'
    });
  }
});

/**
 * PUT /api/admin/system-parameters/:id
 * Actualiza un par√°metro del sistema
 */
router.put('/system-parameters/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { valorParametro, descripcion } = req.body;
    const userId = req.user.id;

    console.log(`[ADMIN] Actualizando par√°metro ${id}:`, { valorParametro, descripcion });

    // Validaciones b√°sicas
    if (!valorParametro) {
      return res.status(400).json({
        success: false,
        message: 'El valor del par√°metro es obligatorio'
      });
    }

    // Verificar que el par√°metro existe
    const parametroExistente = await prisma.parametrosSistema.findUnique({
      where: { id: parseInt(id) }
    });

    if (!parametroExistente) {
      return res.status(404).json({
        success: false,
        message: 'Par√°metro no encontrado'
      });
    }

    // Actualizar par√°metro
    const updatedParameter = await prisma.parametrosSistema.update({
      where: { id: parseInt(id) },
      data: {
        valorParametro: valorParametro.toString(),
        descripcion: descripcion || parametroExistente.descripcion,
        usuarioModificoId: userId,
        fechaModificacion: new Date()
      },
      include: {
        usuarioModifico: {
          select: {
            nombre: true,
            apellido: true,
            email: true
          }
        }
      }
    });

    console.log('‚úÖ Par√°metro actualizado:', updatedParameter.nombreParametro);

    res.status(200).json({
      success: true,
      message: 'Par√°metro actualizado exitosamente',
      data: { parameter: updatedParameter }
    });

  } catch (error) {
    console.error('[ERROR] Error actualizando par√°metro:', error);
    
    if (error.code === 'P2025') {
      return res.status(404).json({
        success: false,
        message: 'Par√°metro no encontrado'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error actualizando par√°metro del sistema'
    });
  }
});

/**
 * POST /api/admin/system-parameters
 * Crea un nuevo par√°metro del sistema (opcional)
 */
router.post('/system-parameters', async (req, res) => {
  try {
    const { nombreParametro, valorParametro, descripcion, tipoDato } = req.body;
    const userId = req.user.id;

    console.log('[ADMIN] Creando nuevo par√°metro:', { nombreParametro, tipoDato });

    // Validaciones
    if (!nombreParametro || !valorParametro || !tipoDato) {
      return res.status(400).json({
        success: false,
        message: 'Nombre, valor y tipo de dato son obligatorios'
      });
    }

    // Verificar que no existe un par√°metro con el mismo nombre
    const parametroExistente = await prisma.parametrosSistema.findUnique({
      where: { nombreParametro }
    });

    if (parametroExistente) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un par√°metro con ese nombre'
      });
    }

    // Crear nuevo par√°metro
    const nuevoParametro = await prisma.parametrosSistema.create({
      data: {
        nombreParametro,
        valorParametro: valorParametro.toString(),
        descripcion: descripcion || null,
        tipoDato,
        usuarioModificoId: userId,
        fechaModificacion: new Date()
      },
      include: {
        usuarioModifico: {
          select: {
            nombre: true,
            apellido: true,
            email: true
          }
        }
      }
    });

    console.log('‚úÖ Nuevo par√°metro creado:', nuevoParametro.nombreParametro);

    res.status(201).json({
      success: true,
      message: 'Par√°metro creado exitosamente',
      data: { parameter: nuevoParametro }
    });

  } catch (error) {
    console.error('[ERROR] Error creando par√°metro:', error);
    
    if (error.code === 'P2002') {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un par√°metro con ese nombre'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error creando par√°metro del sistema'
    });
  }
});

/**
 * DELETE /api/admin/system-parameters/:id
 * Elimina un par√°metro del sistema (usar con precauci√≥n)
 */
router.delete('/system-parameters/:id', async (req, res) => {
  try {
    const { id } = req.params;

    console.log(`[ADMIN] Eliminando par√°metro ${id}...`);

    // Verificar que el par√°metro existe
    const parametroExistente = await prisma.parametrosSistema.findUnique({
      where: { id: parseInt(id) }
    });

    if (!parametroExistente) {
      return res.status(404).json({
        success: false,
        message: 'Par√°metro no encontrado'
      });
    }

    // Eliminar par√°metro
    await prisma.parametrosSistema.delete({
      where: { id: parseInt(id) }
    });

    console.log('‚úÖ Par√°metro eliminado:', parametroExistente.nombreParametro);

    res.status(200).json({
      success: true,
      message: 'Par√°metro eliminado exitosamente'
    });

  } catch (error) {
    console.error('[ERROR] Error eliminando par√°metro:', error);
    
    if (error.code === 'P2025') {
      return res.status(404).json({
        success: false,
        message: 'Par√°metro no encontrado'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error eliminando par√°metro del sistema'
    });
  }
});

// ===== RUTAS DE TIPOS DE ART√çCULOS =====

/**
 * GET /api/admin/article-types
 * Obtiene todos los tipos de art√≠culos
 */
router.get('/article-types', async (req, res) => {
  try {
    console.log('[ADMIN] Obteniendo tipos de art√≠culos...');

    const articleTypes = await prisma.tipoArticulo.findMany({
      orderBy: [
        { estado: 'desc' }, // Activos primero
        { nombre: 'asc' }   // Luego alfab√©tico
      ]
    });

    console.log(`‚úÖ ${articleTypes.length} tipos de art√≠culos encontrados`);

    // Transformar los datos para el frontend
    const transformedTypes = articleTypes.map(type => ({
      id: type.id,
      nombre: type.nombre,
      porcentajeMinAvaluo: parseFloat(type.porcentajeMinAvaluo),
      porcentajeMaxAvaluo: parseFloat(type.porcentajeMaxAvaluo),
      requiereElectronico: type.requiereElectronico,
      estado: type.estado,
      createdAt: type.createdAt,
      updatedAt: type.updatedAt
    }));

    res.status(200).json({
      success: true,
      data: { articleTypes: transformedTypes }
    });

  } catch (error) {
    console.error('[ERROR] Error obteniendo tipos de art√≠culos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo tipos de art√≠culos'
    });
  }
});

/**
 * POST /api/admin/article-types
 * Crea un nuevo tipo de art√≠culo
 */
router.post('/article-types', async (req, res) => {
  try {
    const { nombre, porcentajeMinAvaluo, porcentajeMaxAvaluo, requiereElectronico } = req.body;

    console.log('[ADMIN] Creando nuevo tipo de art√≠culo:', { nombre, porcentajeMinAvaluo, porcentajeMaxAvaluo });

    // Validaciones
    if (!nombre?.trim()) {
      return res.status(400).json({
        success: false,
        message: 'El nombre del tipo es obligatorio'
      });
    }

    if (porcentajeMinAvaluo < 0 || porcentajeMinAvaluo > 100) {
      return res.status(400).json({
        success: false,
        message: 'El porcentaje m√≠nimo debe estar entre 0 y 100'
      });
    }

    if (porcentajeMaxAvaluo < 0 || porcentajeMaxAvaluo > 100) {
      return res.status(400).json({
        success: false,
        message: 'El porcentaje m√°ximo debe estar entre 0 y 100'
      });
    }

    if (porcentajeMinAvaluo >= porcentajeMaxAvaluo) {
      return res.status(400).json({
        success: false,
        message: 'El porcentaje m√≠nimo debe ser menor al m√°ximo'
      });
    }

    // Verificar que no existe un tipo con el mismo nombre
    const tipoExistente = await prisma.tipoArticulo.findFirst({
      where: { 
        nombre: {
          equals: nombre.trim(),
          mode: 'insensitive'
        }
      }
    });

    if (tipoExistente) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un tipo de art√≠culo con ese nombre'
      });
    }

    // Crear nuevo tipo de art√≠culo
    const nuevoTipo = await prisma.tipoArticulo.create({
      data: {
        nombre: nombre.trim(),
        porcentajeMinAvaluo: parseFloat(porcentajeMinAvaluo),
        porcentajeMaxAvaluo: parseFloat(porcentajeMaxAvaluo),
        requiereElectronico: Boolean(requiereElectronico),
        estado: 'Activo'
      }
    });

    console.log('‚úÖ Nuevo tipo de art√≠culo creado:', nuevoTipo.nombre);

    // Transformar para el frontend
    const tipoTransformado = {
      id: nuevoTipo.id,
      nombre: nuevoTipo.nombre,
      porcentajeMinAvaluo: parseFloat(nuevoTipo.porcentajeMinAvaluo),
      porcentajeMaxAvaluo: parseFloat(nuevoTipo.porcentajeMaxAvaluo),
      requiereElectronico: nuevoTipo.requiereElectronico,
      estado: nuevoTipo.estado,
      createdAt: nuevoTipo.createdAt,
      updatedAt: nuevoTipo.updatedAt
    };

    res.status(201).json({
      success: true,
      message: 'Tipo de art√≠culo creado exitosamente',
      data: { articleType: tipoTransformado }
    });

  } catch (error) {
    console.error('[ERROR] Error creando tipo de art√≠culo:', error);
    
    if (error.code === 'P2002') {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un tipo de art√≠culo con ese nombre'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error creando tipo de art√≠culo'
    });
  }
});

/**
 * PUT /api/admin/article-types/:id
 * Actualiza un tipo de art√≠culo
 */
router.put('/article-types/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { nombre, porcentajeMinAvaluo, porcentajeMaxAvaluo, requiereElectronico } = req.body;

    console.log(`[ADMIN] Actualizando tipo de art√≠culo ${id}:`, { nombre, porcentajeMinAvaluo, porcentajeMaxAvaluo });

    // Validaciones
    if (!nombre?.trim()) {
      return res.status(400).json({
        success: false,
        message: 'El nombre del tipo es obligatorio'
      });
    }

    if (porcentajeMinAvaluo < 0 || porcentajeMinAvaluo > 100) {
      return res.status(400).json({
        success: false,
        message: 'El porcentaje m√≠nimo debe estar entre 0 y 100'
      });
    }

    if (porcentajeMaxAvaluo < 0 || porcentajeMaxAvaluo > 100) {
      return res.status(400).json({
        success: false,
        message: 'El porcentaje m√°ximo debe estar entre 0 y 100'
      });
    }

    if (porcentajeMinAvaluo >= porcentajeMaxAvaluo) {
      return res.status(400).json({
        success: false,
        message: 'El porcentaje m√≠nimo debe ser menor al m√°ximo'
      });
    }

    // Verificar que el tipo existe
    const tipoExistente = await prisma.tipoArticulo.findUnique({
      where: { id: parseInt(id) }
    });

    if (!tipoExistente) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    // Verificar que no existe otro tipo con el mismo nombre
    const tipoConMismoNombre = await prisma.tipoArticulo.findFirst({
      where: { 
        nombre: {
          equals: nombre.trim(),
          mode: 'insensitive'
        },
        id: {
          not: parseInt(id)
        }
      }
    });

    if (tipoConMismoNombre) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe otro tipo de art√≠culo con ese nombre'
      });
    }

    // Actualizar tipo de art√≠culo
    const tipoActualizado = await prisma.tipoArticulo.update({
      where: { id: parseInt(id) },
      data: {
        nombre: nombre.trim(),
        porcentajeMinAvaluo: parseFloat(porcentajeMinAvaluo),
        porcentajeMaxAvaluo: parseFloat(porcentajeMaxAvaluo),
        requiereElectronico: Boolean(requiereElectronico)
      }
    });

    console.log('‚úÖ Tipo de art√≠culo actualizado:', tipoActualizado.nombre);

    // Transformar para el frontend
    const tipoTransformado = {
      id: tipoActualizado.id,
      nombre: tipoActualizado.nombre,
      porcentajeMinAvaluo: parseFloat(tipoActualizado.porcentajeMinAvaluo),
      porcentajeMaxAvaluo: parseFloat(tipoActualizado.porcentajeMaxAvaluo),
      requiereElectronico: tipoActualizado.requiereElectronico,
      estado: tipoActualizado.estado,
      createdAt: tipoActualizado.createdAt,
      updatedAt: tipoActualizado.updatedAt
    };

    res.status(200).json({
      success: true,
      message: 'Tipo de art√≠culo actualizado exitosamente',
      data: { articleType: tipoTransformado }
    });

  } catch (error) {
    console.error('[ERROR] Error actualizando tipo de art√≠culo:', error);
    
    if (error.code === 'P2025') {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    if (error.code === 'P2002') {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un tipo de art√≠culo con ese nombre'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error actualizando tipo de art√≠culo'
    });
  }
});

/**
 * PUT /api/admin/article-types/:id/toggle-status
 * Cambia el estado (Activo/Inactivo) de un tipo de art√≠culo
 */
router.put('/article-types/:id/toggle-status', async (req, res) => {
  try {
    const { id } = req.params;

    console.log(`[ADMIN] Cambiando estado del tipo de art√≠culo ${id}...`);

    // Verificar que el tipo existe
    const tipoExistente = await prisma.tipoArticulo.findUnique({
      where: { id: parseInt(id) }
    });

    if (!tipoExistente) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    // Cambiar estado
    const nuevoEstado = tipoExistente.estado === 'Activo' ? 'Inactivo' : 'Activo';
    
    const tipoActualizado = await prisma.tipoArticulo.update({
      where: { id: parseInt(id) },
      data: { estado: nuevoEstado }
    });

    console.log(`‚úÖ Estado cambiado a: ${nuevoEstado} para tipo: ${tipoActualizado.nombre}`);

    // Transformar para el frontend
    const tipoTransformado = {
      id: tipoActualizado.id,
      nombre: tipoActualizado.nombre,
      porcentajeMinAvaluo: parseFloat(tipoActualizado.porcentajeMinAvaluo),
      porcentajeMaxAvaluo: parseFloat(tipoActualizado.porcentajeMaxAvaluo),
      requiereElectronico: tipoActualizado.requiereElectronico,
      estado: tipoActualizado.estado,
      createdAt: tipoActualizado.createdAt,
      updatedAt: tipoActualizado.updatedAt
    };

    res.status(200).json({
      success: true,
      message: `Tipo de art√≠culo ${nuevoEstado.toLowerCase()} exitosamente`,
      data: { articleType: tipoTransformado }
    });

  } catch (error) {
    console.error('[ERROR] Error cambiando estado del tipo de art√≠culo:', error);
    
    if (error.code === 'P2025') {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error cambiando estado del tipo de art√≠culo'
    });
  }
});

/**
 * DELETE /api/admin/article-types/:id
 * Elimina un tipo de art√≠culo (usar con precauci√≥n)
 */
router.delete('/article-types/:id', async (req, res) => {
  try {
    const { id } = req.params;

    console.log(`[ADMIN] Eliminando tipo de art√≠culo ${id}...`);

    // Verificar que el tipo existe
    const tipoExistente = await prisma.tipoArticulo.findUnique({
      where: { id: parseInt(id) }
    });

    if (!tipoExistente) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    // Verificar si existen art√≠culos asociados a este tipo
    const articulosAsociados = await prisma.articulo.count({
      where: { tipoArticuloId: parseInt(id) }
    });

    if (articulosAsociados > 0) {
      return res.status(409).json({
        success: false,
        message: `No se puede eliminar el tipo porque tiene ${articulosAsociados} art√≠culo(s) asociado(s). Desact√≠valo en su lugar.`,
        data: { associatedArticles: articulosAsociados }
      });
    }

    // Eliminar tipo de art√≠culo
    await prisma.tipoArticulo.delete({
      where: { id: parseInt(id) }
    });

    console.log('‚úÖ Tipo de art√≠culo eliminado:', tipoExistente.nombre);

    res.status(200).json({
      success: true,
      message: 'Tipo de art√≠culo eliminado exitosamente'
    });

  } catch (error) {
    console.error('[ERROR] Error eliminando tipo de art√≠culo:', error);
    
    if (error.code === 'P2025') {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    if (error.code === 'P2003') {
      return res.status(409).json({
        success: false,
        message: 'No se puede eliminar el tipo porque tiene art√≠culos asociados'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error eliminando tipo de art√≠culo'
    });
  }
});

/**
 * GET /api/admin/article-types/:id/articles
 * Obtiene todos los art√≠culos asociados a un tipo espec√≠fico
 */
router.get('/article-types/:id/articles', async (req, res) => {
  try {
    const { id } = req.params;
    const { page = 1, limit = 10 } = req.query;

    console.log(`[ADMIN] Obteniendo art√≠culos del tipo ${id}...`);

    // Verificar que el tipo existe
    const tipoExistente = await prisma.tipoArticulo.findUnique({
      where: { id: parseInt(id) }
    });

    if (!tipoExistente) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de art√≠culo no encontrado'
      });
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [articulos, totalArticulos] = await Promise.all([
      prisma.articulo.findMany({
        where: { tipoArticuloId: parseInt(id) },
        include: {
          solicitud: {
            include: {
              usuario: {
                select: {
                  nombre: true,
                  apellido: true,
                  email: true
                }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: parseInt(limit)
      }),
      prisma.articulo.count({
        where: { tipoArticuloId: parseInt(id) }
      })
    ]);

    console.log(`‚úÖ ${articulos.length} art√≠culos encontrados para el tipo: ${tipoExistente.nombre}`);

    res.status(200).json({
      success: true,
      data: {
        articleType: tipoExistente,
        articles: articulos,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalArticulos / parseInt(limit)),
          totalItems: totalArticulos,
          itemsPerPage: parseInt(limit)
        }
      }
    });

  } catch (error) {
    console.error('[ERROR] Error obteniendo art√≠culos del tipo:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo art√≠culos del tipo'
    });
  }
});

// ===== RUTAS ADICIONALES DEL SISTEMA =====

/**
 * POST /api/admin/backup-database
 * Crea un respaldo de la base de datos (placeholder)
 */
router.post('/backup-database', async (req, res) => {
  try {
    console.log('[ADMIN] Solicitud de respaldo de base de datos...');

    // TODO: Implementar l√≥gica real de respaldo
    const backupInfo = {
      timestamp: new Date().toISOString(),
      requestedBy: req.user.email,
      status: 'simulated',
      message: 'Funcionalidad de respaldo pendiente de implementaci√≥n'
    };

    res.status(200).json({
      success: true,
      message: 'Respaldo simulado exitosamente',
      data: { backup: backupInfo }
    });

  } catch (error) {
    console.error('[ERROR] Error en respaldo:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando respaldo de la base de datos'
    });
  }
});

/**
 * GET /api/admin/system-health
 * Verifica el estado del sistema
 */
router.get('/system-health', async (req, res) => {
  try {
    console.log('[ADMIN] Verificando estado del sistema...');

    const healthCheck = {
      database: 'unknown',
      totalUsers: 0,
      activeConnections: 0,
      systemStatus: 'unknown',
      timestamp: new Date().toISOString()
    };

    try {
      // Verificar conexi√≥n a base de datos
      await prisma.$connect();
      healthCheck.database = 'connected';
      
      // Obtener m√©tricas b√°sicas
      healthCheck.totalUsers = await prisma.usuario.count();
      healthCheck.activeConnections = await prisma.sesionUsuario.count({
        where: {
          fechaFin: null
        }
      });
      
      healthCheck.systemStatus = 'healthy';
      
    } catch (dbError) {
      console.error('Error en health check de BD:', dbError);
      healthCheck.database = 'error';
      healthCheck.systemStatus = 'degraded';
    }

    const statusCode = healthCheck.systemStatus === 'healthy' ? 200 : 503;

    res.status(statusCode).json({
      success: healthCheck.systemStatus === 'healthy',
      data: { health: healthCheck }
    });

  } catch (error) {
    console.error('[ERROR] Error en verificaci√≥n del sistema:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando estado del sistema'
    });
  }
});

// ===== MIDDLEWARE DE ERROR ESPEC√çFICO PARA ADMIN =====
router.use((error, req, res, next) => {
  console.error('‚ùå Error en rutas de admin:', error);
  
  res.status(error.status || 500).json({
    success: false,
    message: 'Error en API de administraci√≥n',
    error: process.env.NODE_ENV === 'development' ? error.message : 'Error interno del servidor'
  });
});

export default router;